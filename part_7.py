import string

# Анализ текста. Популярность
def popularity_count(text)->(dict,dict):

    text_processing = text.translate(str.maketrans('', '', string.punctuation)) # удаление знаков препинания

    words = text_processing.split(" ") # получение списка из слов
    letters = text_processing.replace(" ","") # получение строки букв

    # объявление словарей
    words_popularity = {}
    letters_popularity = {}

    for word in set(words): # в цикле по уникальным словам (set позволяет получить уникальные элементы)
        words_popularity[word] = text.count(word) # подсчитываем количество слов с оригинальной строке

    for letter in set(letters): # в цикле по уникальным буквам (set позволяет получить уникальные элементы)
        letters_popularity[letter] = text.count(letter) # подсчитываем количество букв в оргинальной строке

    return words_popularity,letters_popularity

# Ленивый спекулянт
def lazy_trader(rates)->dict:
    min_value = min(rates.values()) # получение минимального значения в словаре
    best_banks = {} # объявление словаря банков

    for key in rates:
        if rates[key] == min_value: # если у банка значение акции совпадает с минимальным
            best_banks[key] = min_value # добавляем в словарь этот банк

    return best_banks

# Вверх дном
def reverse_dict(book)->dict:
    reverse_book = {}
    for key,value in book.items():
     reverse_book[value] = key
    return reverse_book

# Структурируем данные
def merge_lists(dates,rates)->dict:
    return dict(zip(dates, rates)) # возвращаем словарь из объединенных при помощи zip списков

def int_to_roman(num)->str:
        res = ""
        dict_roman = {
            1000: "M",
            900: "CM",
            500: "D",
            400: "CD",
            100: "C",
            90: "XC",
            50: "L",
            40: "XL",
            10: "X",
            9: "IX",
            5: "V",
            4: "IV",
            1: "I",
        }
        for int, roman in dict_roman.items(): # перебираем все числа и соответсвующее им римское представление
            div, mod = divmod(num, int) # получаем целое и остаток от деления нашего числа на число из списка
            res += roman * div # прибавляем к результирующей строке такое количество римского числа, сколько раз нацело разделилось исходное число
            num = mod # продолжаем работать с остатком от деления

        return res

        """
        пример 1: на вход число 520
        520/1000 - остаток от деления 520, целая часть 0; к результату прибавлять нечего (будет пустая строка)
        520/900 - аналогично
        520/500 - целая часть 1, остаток от деления 20; к результату прибавляем строку D (т.к D * 1 раз)
        20/400 - 20/40 - ничего не прибавляем
        20/10 - целая часть 2, остаток от деления 0, к результату прибавляем строку XX (т.к X * 2 раза)
        итог : DXX

        пример 2: на вход число 27
        до деления на 10 ничего не добавляется
        27/10 = целая часть 2, остаток от деленния 7, к результату прибавляем строку XX (т.к X * 2 раза)
        7/10 - 7/9 - ничего
        7/5 = целая часть 1, остаток от деления 2, к результату прибавляем строку V
        2/4 - ничего
        2/1 - целая часть 2, остаток от деления 0, к результату прибавляем строку II (т.к I * 2 раза)
        итог: XXVII
        
        пример 3: на вход число 60
        до деления на 50 ничего
        60/50 - целая часть 1, остаток от деления 10, к результату прибавляем L
        до деления на 10 ничего
        10/10 - целая часть 1, остаток от деления 0, к результату прибавляем X
        итог: LX
        """






